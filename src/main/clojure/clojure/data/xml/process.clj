(ns clojure.data.xml.process
  {:lang :core.typed
   :core.typed {:features #{:runtime-infer}}}
  (:require [clojure.data.xml.event :refer [element-nss] :as evt]
            [clojure.data.xml.name :as name :refer [gen-prefix *gen-prefix-counter* qname-uri]]
            [clojure.data.xml.node :refer [element] :as node]
            [clojure.data.xml.tree :refer [flatten-elements] :as tree]
            [clojure.core.typed :as t]
            [clojure.spec :as s]
            [clojure.string :as str]))

;; Start: Generated by clojure.core.typed - DO NOT EDIT
(s/fdef
  aggregate-xmlns
  :args
  (s/cat :xml (partial instance? clojure.data.xml.node.Element))
  :ret
  (partial instance? clojure.data.xml.node.Element))
(s/def ::alias__44658 any?)
(s/def
  ::alias__44659
  (s/and
    (partial
      instance?
      clojure.lang.PersistentHashSet$TransientHashSet)))
(s/def
  ::alias__44657
  (s/and
    (partial
      instance?
      clojure.lang.PersistentHashSet$TransientHashSet)))
(s/fdef
  reduce-tree
  :args
  (s/cat
    :f
    ifn?
    :init
    (partial instance? clojure.lang.PersistentHashSet$TransientHashSet)
    :xml
    (partial instance? clojure.data.xml.node.Element))
  :ret
  (partial instance? clojure.lang.PersistentHashSet$TransientHashSet))
(s/def ::alias__44675 any?)
(s/def
  ::alias__44673
  (s/and
    (partial
      instance?
      clojure.lang.PersistentHashSet$TransientHashSet)))
(s/def
  ::alias__44676
  (s/and
    (partial
      instance?
      clojure.lang.PersistentHashSet$TransientHashSet)))
(s/def
  ::alias__44674
  (s/and
    (partial
      instance?
      clojure.lang.PersistentHashSet$TransientHashSet)))
(s/def ::alias__44672 string?)
(s/def
  ::alias__44671
  (s/and
    (partial
      instance?
      clojure.lang.PersistentHashSet$TransientHashSet)))
(s/fdef qname-uri-xf :args (s/cat :xf ifn?) :ret ifn?)
(s/fdef
  find-xmlns
  :args
  (s/cat :xml (partial instance? clojure.data.xml.node.Element))
  :ret
  set?)
;; End: Generated by clojure.core.typed - DO NOT EDIT
(defn- reduce-tree
  "Optimized reducer for in-order traversal of nodes, with reduce-like accumulator"
  [f init xml]
  (loop [result init
         {:as tree [child & next-children :as children] :content} xml
         [parent & next-parents :as parents] ()]
    (if (seq children)
      (recur (f result tree)
             child
             (concat next-children parents))
      (if (seq parents)
        (recur (f result tree)
               parent
               next-parents)
        (f result tree)))))

(defn- qname-uri-xf [xf]
  (fn [s el]
    (if (map? el)
      (reduce-kv
       (fn [s attr _] (xf s (qname-uri attr)))
       (xf s (qname-uri (:tag el))) (:attrs el))
      s)))

(defn find-xmlns
  "Find all xmlns occuring in a root"
  [xml]
  (persistent!
   (reduce-tree (qname-uri-xf conj!)
                (transient #{}) xml)))

(defn aggregate-xmlns
  "Put all occurring xmlns into the root"
  [xml]
  (with-meta
    xml {:clojure.data.xml/nss
         (binding [*gen-prefix-counter* 0]
           (persistent!
            (reduce (fn [tm uri]
                      (if (str/blank? uri)
                        tm
                        (assoc! tm (keyword "xmlns" (gen-prefix)) uri)))
                    (transient {}) (find-xmlns xml))))}))