;   Copyright (c) Rich Hickey. All rights reserved.
;   The use and distribution terms for this software are covered by the
;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;   which can be found in the file epl-v10.html at the root of this distribution.
;   By using this software in any fashion, you are agreeing to be bound by
;   the terms of this license.
;   You must not remove this notice, or any other, from this software.

(ns ^{:doc "Functions to parse XML into lazy sequences and lazy trees and
  emit these as text."
      :author "Chris Houser"
      :lang :core.typed
      :core.typed {:features #{:runtime-infer}}}

  clojure.data.xml
  
  (:require
   (clojure.data.xml
    [process :as process]
    [impl :refer [export-api]]
    [node :as node]
    [prxml :as prxml]
    [name :as name]
    [event :as event])
   (clojure.data.xml.jvm
    [pprint :refer
     [indent-xml]]
    [parse :refer
     [pull-seq string-source make-stream-reader]]
    [emit :refer
     [write-document string-writer]])
   
   [clojure.core.typed :as t]
   [clojure.data.xml.tree :refer
    [event-tree flatten-elements]]))


;; Start: Generated by clojure.core.typed - DO NOT EDIT
(declare
 alias__56381
 alias__56122
 alias__56230
 alias__43750
 alias__54211
 alias__56382
 alias__54263
 alias__56288
 alias__43646
 alias__43583
 alias__56116
 alias__56216)
(clojure.core.typed/defalias
 alias__56381
 '{:with-attr clojure.core.typed/Str})
(clojure.core.typed/defalias
 alias__56122
 '{:j clojure.core.typed/Str,
   :h clojure.core.typed/Str,
   :i clojure.core.typed/Str})
(clojure.core.typed/defalias alias__56230 '{:bg clojure.core.typed/Str})
(clojure.core.typed/defalias
 alias__43750
 (clojure.core.typed/U
  ':tag2
  clojure.core.typed/Str
  ':tag1
  (clojure.core.typed/Vec
   (clojure.core.typed/U
    (clojure.core.typed/Seqable
     (clojure.core.typed/Vec
      (clojure.core.typed/U ':-cdata clojure.core.typed/Str)))
    (clojure.core.typed/Vec
     (clojure.core.typed/U ':-cdata clojure.core.typed/Str))
    (clojure.core.typed/Vec clojure.core.typed/Str)
    (clojure.core.typed/Seqable
     (clojure.core.typed/Vec clojure.core.typed/Str))
    ':body
    (clojure.core.typed/Map
     clojure.core.typed/Nothing
     clojure.core.typed/Nothing)))
  ':body
  ':tag))
(clojure.core.typed/defalias
 alias__54211
 (clojure.core.typed/U
  ':tag2
  (clojure.core.typed/Vec
   (clojure.core.typed/U
    (clojure.core.typed/Seqable
     (clojure.core.typed/Vec
      (clojure.core.typed/U ':-cdata clojure.core.typed/Str)))
    (clojure.core.typed/Vec
     (clojure.core.typed/U ':-cdata clojure.core.typed/Str))
    (clojure.core.typed/Vec clojure.core.typed/Str)
    (clojure.core.typed/Seqable
     (clojure.core.typed/Vec clojure.core.typed/Str))
    ':body
    (clojure.core.typed/Map
     clojure.core.typed/Nothing
     clojure.core.typed/Nothing)
    (clojure.core.typed/Vec
     (clojure.core.typed/U
      ':-comment
      ':-cdata
      clojure.core.typed/Str))))
  alias__56382
  clojure.core.typed/Str
  ':tag1
  ':body
  ':tag))
(clojure.core.typed/defalias
 alias__56382
 '{:attr clojure.core.typed/Str})
(clojure.core.typed/defalias
 alias__54263
 (clojure.core.typed/U
  ':tag2
  (clojure.core.typed/Vec
   (clojure.core.typed/U
    (clojure.core.typed/Seqable
     (clojure.core.typed/Vec
      (clojure.core.typed/U ':-cdata clojure.core.typed/Str)))
    (clojure.core.typed/Vec
     (clojure.core.typed/U ':-cdata clojure.core.typed/Str))
    (clojure.core.typed/Vec clojure.core.typed/Str)
    (clojure.core.typed/Seqable
     (clojure.core.typed/Vec clojure.core.typed/Str))
    ':body
    (clojure.core.typed/Map
     clojure.core.typed/Nothing
     clojure.core.typed/Nothing)
    (clojure.core.typed/Vec
     (clojure.core.typed/U
      ':-comment
      ':-cdata
      clojure.core.typed/Str))))
  clojure.core.typed/Str
  ':tag1
  ':body))
(clojure.core.typed/defalias
 alias__56288
 '{:m clojure.core.typed/Str, :l clojure.core.typed/Str})
(clojure.core.typed/defalias
 alias__43646
 (clojure.core.typed/U
  ':tag2
  (clojure.core.typed/Vec
   (clojure.core.typed/U
    (clojure.core.typed/Seqable
     (clojure.core.typed/Vec
      (clojure.core.typed/U ':-cdata clojure.core.typed/Str)))
    (clojure.core.typed/Vec
     (clojure.core.typed/U ':-cdata clojure.core.typed/Str))
    (clojure.core.typed/Vec clojure.core.typed/Str)
    (clojure.core.typed/Seqable
     (clojure.core.typed/Vec clojure.core.typed/Str))
    ':body
    (clojure.core.typed/Map
     clojure.core.typed/Nothing
     clojure.core.typed/Nothing)
    (clojure.core.typed/Vec
     (clojure.core.typed/U
      ':-comment
      ':-cdata
      clojure.core.typed/Str))))
  alias__56382
  clojure.core.typed/Str
  ':tag1
  ':body
  ':tag))
(clojure.core.typed/defalias
 alias__43583
 (clojure.core.typed/U
  ':tag2
  (clojure.core.typed/Vec
   (clojure.core.typed/U
    (clojure.core.typed/Seqable
     (clojure.core.typed/Vec
      (clojure.core.typed/U ':-cdata clojure.core.typed/Str)))
    (clojure.core.typed/Vec
     (clojure.core.typed/U ':-cdata clojure.core.typed/Str))
    (clojure.core.typed/Vec clojure.core.typed/Str)
    (clojure.core.typed/Seqable
     (clojure.core.typed/Vec clojure.core.typed/Str))
    ':body
    (clojure.core.typed/Map
     clojure.core.typed/Nothing
     clojure.core.typed/Nothing)
    (clojure.core.typed/Vec
     (clojure.core.typed/U
      ':-comment
      ':-cdata
      clojure.core.typed/Str))))
  alias__56382
  clojure.core.typed/Str
  ':tag1
  ':body
  ':tag))
(clojure.core.typed/defalias
 alias__56116
 '{:include-node?
   (clojure.core.typed/Set
    (clojure.core.typed/U ':element ':characters)),
   :coalescing (clojure.core.typed/U Boolean false),
   :supporting-external-entities false})
(clojure.core.typed/defalias alias__56216 '{:k clojure.core.typed/Str})
(clojure.core.typed/ann clojure.data.xml.name/alias-ns AnyFunction)
(clojure.core.typed/ann cdata AnyFunction)
(clojure.core.typed/ann
 clojure.data.xml.name/qname-local
 clojure.lang.Var)
(clojure.core.typed/ann qname-local clojure.lang.Var)
(clojure.core.typed/ann clojure.data.xml.name/ns-uri AnyFunction)
(clojure.core.typed/ann
 clojure.data.xml.prxml/sexps-as-fragment
 [(clojure.core.typed/Seqable
   (clojure.core.typed/Vec
    (clojure.core.typed/U ':tag2 clojure.core.typed/Str ':tag1)))
  :->
  (clojure.core.typed/Seqable clojure.data.xml.node.Element)])
(clojure.core.typed/ann alias-ns AnyFunction)
(clojure.core.typed/ann clojure.data.xml.name/declare-ns AnyFunction)
(clojure.core.typed/ann
 clojure.data.xml.process/aggregate-xmlns
 AnyFunction)
(clojure.core.typed/ann ns-uri AnyFunction)
(clojure.core.typed/ann declare-ns AnyFunction)
(clojure.core.typed/ann aggregate-xmlns AnyFunction)
(clojure.core.typed/ann
 sexp-as-element
 [(clojure.core.typed/U
   (clojure.core.typed/Vec
    (clojure.core.typed/U
     (clojure.core.typed/Vec
      (clojure.core.typed/Seqable (clojure.core.typed/Vec ':-cdata)))
     alias__43750
     alias__43646
     alias__43583))
   (clojure.core.typed/Seqable
    (clojure.core.typed/Vec
     (clojure.core.typed/U ':tag2 clojure.core.typed/Str ':tag1))))
  :->
  clojure.data.xml.node.Element])
(clojure.core.typed/ann clojure.data.xml.name/parse-qname AnyFunction)
(clojure.core.typed/ann uri-ns AnyFunction)
(clojure.core.typed/ann indent AnyFunction)
(clojure.core.typed/ann clojure.data.xml.name/uri-ns AnyFunction)
(clojure.core.typed/ann element-nss AnyFunction)
(clojure.core.typed/ann indent-str AnyFunction)
(clojure.core.typed/ann
 clojure.data.xml.jvm.parse/make-stream-reader
 [alias__56116
  (clojure.core.typed/U
   java.io.ByteArrayInputStream
   java.io.StringReader)
  :->
  com.sun.org.apache.xerces.internal.impl.XMLStreamReaderImpl])
(clojure.core.typed/ann
 clojure.data.xml.tree/event-tree
 [(clojure.core.typed/Seqable
   (clojure.core.typed/U
    clojure.data.xml.event.StartElementEvent
    clojure.data.xml.event.EndElementEvent
    clojure.data.xml.event.CharsEvent))
  :->
  clojure.data.xml.node.Element])
(clojure.core.typed/ann clojure.data.xml.name/qname AnyFunction)
(clojure.core.typed/ann
 parse
 (clojure.core.typed/IFn
  [(clojure.core.typed/U
    java.io.ByteArrayInputStream
    java.io.StringReader)
   :->
   clojure.data.xml.node.Element]
  [java.io.StringReader
   ':coalescing
   false
   :->
   clojure.data.xml.node.Element]))
(clojure.core.typed/ann
 element
 (clojure.core.typed/IFn
  [':a
   alias__56122
   clojure.core.typed/Str
   clojure.data.xml.node.Element
   clojure.core.typed/Str
   clojure.data.xml.node.Element
   clojure.core.typed/Str
   clojure.data.xml.node.Element
   clojure.core.typed/Str
   clojure.data.xml.node.Element
   clojure.core.typed/Str
   clojure.data.xml.node.Element
   clojure.core.typed/Str
   :->
   clojure.data.xml.node.Element]
  [(clojure.core.typed/U
    ':h1
    ':c
    ':g
    ':here
    ':d
    ':comment
    ':ATag
    ':html
    ':body
    ':f
    ':b
    ':cdata
    ':tag
    ':is)
   (clojure.core.typed/U
    alias__56381
    alias__56216
    alias__56382
    (clojure.core.typed/Map
     clojure.core.typed/Nothing
     clojure.core.typed/Nothing))
   (clojure.core.typed/U
    clojure.data.xml.node.Comment
    clojure.core.typed/Str
    clojure.data.xml.node.CData
    clojure.data.xml.node.Element)
   :->
   clojure.data.xml.node.Element]
  [(clojure.core.typed/U ':body ':e)
   (clojure.core.typed/U alias__56230 alias__56288)
   clojure.core.typed/Str
   clojure.data.xml.node.Element
   clojure.core.typed/Str
   :->
   clojure.data.xml.node.Element]
  [(clojure.core.typed/U ':a ':body)
   (clojure.core.typed/Map
    clojure.core.typed/Nothing
    clojure.core.typed/Nothing)
   (clojure.core.typed/U
    clojure.data.xml.node.CData
    clojure.data.xml.node.Element)
   (clojure.core.typed/U
    clojure.data.xml.node.CData
    clojure.data.xml.node.Element)
   :->
   clojure.data.xml.node.Element]))
(clojure.core.typed/ann qname AnyFunction)
(clojure.core.typed/ann
 emit-str
 [clojure.data.xml.node.Element :-> clojure.core.typed/Str])
(clojure.core.typed/ann element* AnyFunction)
(clojure.core.typed/ann
 parse-str
 (clojure.core.typed/IFn
  [clojure.core.typed/Str :-> clojure.data.xml.node.Element]
  [clojure.core.typed/Str
   ':coalescing
   false
   :->
   clojure.data.xml.node.Element]))
(clojure.core.typed/ann clojure.data.xml.node/xml-comment AnyFunction)
(clojure.core.typed/ann clojure.data.xml.node/cdata AnyFunction)
(clojure.core.typed/ann clojure.data.xml.name/to-qname AnyFunction)
(clojure.core.typed/ann
 clojure.data.xml.name/qname-uri
 clojure.lang.Var)
(clojure.core.typed/ann parse-qname AnyFunction)
(clojure.core.typed/ann
 clojure.data.xml.jvm.emit/write-document
 [java.io.StringWriter
  (clojure.core.typed/Seqable
   (clojure.core.typed/U
    clojure.data.xml.event.StartElementEvent
    clojure.data.xml.event.CDataEvent
    clojure.data.xml.event.EndElementEvent))
  nil
  :->
  java.io.StringWriter])
(clojure.core.typed/ann
 sexps-as-fragment
 [(clojure.core.typed/Seqable
   (clojure.core.typed/Vec
    (clojure.core.typed/U ':tag2 clojure.core.typed/Str ':tag1)))
  :->
  (clojure.core.typed/Seqable clojure.data.xml.node.Element)])
(clojure.core.typed/ann to-qname AnyFunction)
(clojure.core.typed/ann clojure.data.xml.event/element-nss AnyFunction)
(clojure.core.typed/ann
 clojure.data.xml.jvm.parse/string-source
 [clojure.core.typed/Str :-> java.io.StringReader])
(clojure.core.typed/ann canonical-name AnyFunction)
(clojure.core.typed/ann clojure.data.xml.node/element* AnyFunction)
(clojure.core.typed/ann qname-uri clojure.lang.Var)
(clojure.core.typed/ann
 clojure.data.xml.tree/flatten-elements
 [(clojure.core.typed/Vec clojure.data.xml.node.Element)
  :->
  (clojure.core.typed/Seqable
   (clojure.core.typed/U
    clojure.data.xml.event.StartElementEvent
    clojure.data.xml.event.CDataEvent
    clojure.data.xml.event.EndElementEvent))])
(clojure.core.typed/ann
 clojure.data.xml.jvm.emit/string-writer
 [:-> java.io.StringWriter])
(clojure.core.typed/ann clojure.data.xml.process/find-xmlns AnyFunction)
(clojure.core.typed/ann
 clojure.data.xml.jvm.parse/pull-seq
 [com.sun.org.apache.xerces.internal.impl.XMLStreamReaderImpl
  (clojure.core.typed/Set
   (clojure.core.typed/U ':element ':characters))
  nil
  :->
  (clojure.core.typed/Seqable
   (clojure.core.typed/U
    clojure.data.xml.event.StartElementEvent
    clojure.data.xml.event.EndElementEvent
    clojure.data.xml.event.CharsEvent))])
(clojure.core.typed/ann
 event-seq
 [(clojure.core.typed/U
   java.io.ByteArrayInputStream
   java.io.StringReader)
  (clojure.core.typed/U
   nil
   (clojure.core.typed/Seqable
    (clojure.core.typed/U false ':coalescing)))
  :->
  (clojure.core.typed/Seqable
   (clojure.core.typed/U
    clojure.data.xml.event.StartElementEvent
    clojure.data.xml.event.EndElementEvent
    clojure.data.xml.event.CharsEvent))])
(clojure.core.typed/ann
 clojure.data.xml.prxml/sexp-as-element
 [(clojure.core.typed/U
   (clojure.core.typed/Seqable
    (clojure.core.typed/Vec
     (clojure.core.typed/U clojure.core.typed/Str ':tag1)))
   (clojure.core.typed/Vec
    (clojure.core.typed/U alias__54263 alias__54211))
   (clojure.core.typed/Vec alias__54263)
   (clojure.core.typed/Seqable
    (clojure.core.typed/Vec clojure.core.typed/Str))
   (clojure.core.typed/Seqable
    (clojure.core.typed/Vec
     (clojure.core.typed/U ':tag2 clojure.core.typed/Str ':tag1))))
  :->
  clojure.data.xml.node.Element])
(clojure.core.typed/ann
 emit
 [clojure.data.xml.node.Element
  java.io.StringWriter
  :->
  java.io.StringWriter])
(clojure.core.typed/ann find-xmlns AnyFunction)
(clojure.core.typed/ann xml-comment AnyFunction)
(clojure.core.typed/ann
 clojure.data.xml.node/element
 (clojure.core.typed/IFn
  [':a
   alias__56122
   clojure.core.typed/Str
   clojure.data.xml.node.Element
   clojure.core.typed/Str
   clojure.data.xml.node.Element
   clojure.core.typed/Str
   clojure.data.xml.node.Element
   clojure.core.typed/Str
   clojure.data.xml.node.Element
   clojure.core.typed/Str
   clojure.data.xml.node.Element
   clojure.core.typed/Str
   :->
   clojure.data.xml.node.Element]
  [(clojure.core.typed/U ':body ':e)
   (clojure.core.typed/U alias__56230 alias__56288)
   clojure.core.typed/Str
   clojure.data.xml.node.Element
   clojure.core.typed/Str
   :->
   clojure.data.xml.node.Element]
  [(clojure.core.typed/U
    ':h1
    ':c
    ':g
    ':here
    ':d
    ':comment
    ':ATag
    ':html
    ':body
    ':f
    ':b
    ':cdata
    ':tag
    ':is)
   (clojure.core.typed/U
    alias__56381
    alias__56216
    alias__56382
    (clojure.core.typed/Map
     clojure.core.typed/Nothing
     clojure.core.typed/Nothing))
   (clojure.core.typed/U
    clojure.data.xml.node.Comment
    clojure.core.typed/Str
    clojure.data.xml.node.CData
    clojure.data.xml.node.Element)
   :->
   clojure.data.xml.node.Element]
  [(clojure.core.typed/U ':a ':body)
   (clojure.core.typed/Map
    clojure.core.typed/Nothing
    clojure.core.typed/Nothing)
   (clojure.core.typed/U
    clojure.data.xml.node.CData
    clojure.data.xml.node.Element)
   (clojure.core.typed/U
    clojure.data.xml.node.CData
    clojure.data.xml.node.Element)
   :->
   clojure.data.xml.node.Element]))
;; End: Generated by clojure.core.typed - DO NOT EDIT

(export-api node/element* node/element node/cdata node/xml-comment
            prxml/sexp-as-element prxml/sexps-as-fragment event/element-nss
            name/ns-uri name/uri-ns name/declare-ns name/alias-ns
            name/parse-qname name/qname-uri name/qname-local name/qname name/to-qname
            process/find-xmlns process/aggregate-xmlns)

(defn canonical-name
  "Put (q)name into canonical form as per ns-env"
  [n]
  (name/canonical-name (qname-uri n) (qname-local n) ""))

(defn event-seq
  "Parses the XML InputSource source using a pull-parser. Returns
   a lazy sequence of Event records.  Accepts key pairs
   with XMLInputFactory options, see http://docs.oracle.com/javase/6/docs/api/javax/xml/stream/XMLInputFactory.html
   and xml-input-factory-props for more information.
   Defaults coalescing true and supporting-external-entities false.
   :include-node? can be a set of #{:start-element :end-element :characters :comment}"
  [source {:as props}]
  (let [props* (merge {:include-node? #{:element :characters}
                       :coalescing true
                       :supporting-external-entities false}
                      props)]
    (pull-seq (make-stream-reader props* source)
              (get props* :include-node?)
              nil)))

(defn parse
  "Parses the source, which can be an
   InputStream or Reader, and returns a lazy tree of Element records. Accepts key pairs
   with XMLInputFactory options, see http://docs.oracle.com/javase/6/docs/api/javax/xml/stream/XMLInputFactory.html
   and xml-input-factory-props for more information. Defaults coalescing true."
  [source & opts]
  (event-tree (event-seq source opts)))

(defn parse-str
  "Parses the passed in string to Clojure data structures.  Accepts key pairs
   with XMLInputFactory options, see http://docs.oracle.com/javase/6/docs/api/javax/xml/stream/XMLInputFactory.html
   and xml-input-factory-props for more information. Defaults coalescing true."
  [s & opts]
  (apply parse (string-source s) opts))

(defn emit
  "Prints the given Element tree as XML text to stream.
   Options:
    :encoding <str>          Character encoding to use
    :doctype  <str>          Document type (DOCTYPE) declaration to use"
  [e writer & {:as opts}]
  (write-document writer (flatten-elements [e]) opts))

(defn emit-str
  "Emits the Element to String and returns it.
   Options:
    :encoding <str>          Character encoding to use
    :doctype  <str>          Document type (DOCTYPE) declaration to use"
  ([e & opts]
   (let [sw (string-writer)]
     (apply emit e sw opts)
     (str sw))))

(defn indent
  "Emits the XML and indents the result.  WARNING: this is slow
   it will emit the XML and read it in again to indent it.  Intended for
   debugging/testing only."
  [e writer & opts]
  (indent-xml (apply emit-str e opts) writer))

(defn indent-str
  "Emits the XML and indents the result.  Writes the results to a String and returns it"
  [e & opts]
  (let [sw (string-writer)]
    (apply indent e sw opts)
    (str sw)))

;; TODO implement ~normalize to simulate an emit-parse roundtrip
;;      in terms of xmlns environment and keywords vs qnames
