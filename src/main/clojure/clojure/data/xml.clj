;   Copyright (c) Rich Hickey. All rights reserved.
;   The use and distribution terms for this software are covered by the
;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;   which can be found in the file epl-v10.html at the root of this distribution.
;   By using this software in any fashion, you are agreeing to be bound by
;   the terms of this license.
;   You must not remove this notice, or any other, from this software.

(ns ^{:doc "Functions to parse XML into lazy sequences and lazy trees and
  emit these as text."
      :author "Chris Houser"
      :lang :core.typed
      :core.typed {:features #{:runtime-infer}}}

  clojure.data.xml
  
  (:require
   (clojure.data.xml
    [process :as process]
    [impl :refer [export-api]]
    [node :as node]
    [prxml :as prxml]
    [name :as name]
    [event :as event])
   (clojure.data.xml.jvm
    [pprint :refer
     [indent-xml]]
    [parse :refer
     [pull-seq string-source make-stream-reader]]
    [emit :refer
     [write-document string-writer]])
   
   [clojure.core.typed :as t]
   [clojure.spec :as s]
   [clojure.data.xml.tree :refer
    [event-tree flatten-elements]]))

;; Start: Generated by clojure.core.typed - DO NOT EDIT
(declare
  ABMap
  CoalescingIncludeNode?SupportingExternalEntitiesMap
  ContentTagAttrsMap
  HIJMap
  Ns>xsXs>nsMap
  XmlnsMap
  alias__23814
  alias__24617
  alias__25293)
(t/defalias ABMap '#:xmlns{:a t/Str, :b t/Str})
(t/defalias
  CoalescingIncludeNode?SupportingExternalEntitiesMap
  '{:coalescing Boolean,
    :include-node? (t/Set (t/U ':element ':characters)),
    :supporting-external-entities Boolean})
(t/defalias
  ContentTagAttrsMap
  (t/HMap
    :mandatory
    {:content
     (t/U t/Str '[(t/U t/Str alias__25293 alias__24617 alias__23814)]),
     :tag (t/U ':xml.dav/limit t/Str ':xml.dav/nresults)}
    :optional
    {:attrs (t/Map (t/U t/Str ':xmlns/D) (t/U t/Str t/Int))}))
(t/defalias HIJMap '{:h t/Str, :i t/Str, :j t/Str})
(t/defalias
  Ns>xsXs>nsMap
  '{:ns->xs (t/Map (t/U t/Str t/Sym) t/Str),
    :xs->ns (t/Map t/Str (t/U t/Str t/Sym))})
(t/defalias XmlnsMap '{:xmlns t/Str})
(t/defalias
  alias__23814
  (t/U
    ContentTagAttrsMap
    (t/Coll
      (t/U
        clojure.data.xml.event.StartElementEvent
        clojure.data.xml.event.EndElementEvent
        clojure.data.xml.event.CharsEvent))
    clojure.data.xml.node.Element))
(t/defalias
  alias__24617
  (t/U
    ContentTagAttrsMap
    (t/Coll
      (t/U
        clojure.data.xml.event.StartElementEvent
        clojure.data.xml.event.EndElementEvent
        clojure.data.xml.event.CharsEvent))
    clojure.data.xml.node.Element))
(t/defalias
  alias__25293
  (t/U
    ContentTagAttrsMap
    (t/Coll
      (t/U
        clojure.data.xml.event.StartElementEvent
        clojure.data.xml.event.EndElementEvent
        clojure.data.xml.event.CharsEvent))
    clojure.data.xml.node.Element))
(t/ann
  aggregate-xmlns
  [clojure.data.xml.node.Element :-> clojure.data.xml.node.Element])
(t/ann
  alias-ns
  [':U
   ':test.xmlns.u
   t/Sym
   t/Sym
   t/Str
   t/Str
   ':D
   ':xml.dav
   ':T
   clojure.lang.Namespace
   :->
   nil])
(t/ann canonical-name AnyFunction)
(t/ann cdata AnyFunction)
(t/ann
  declare-ns
  [':xml.dav
   t/Str
   ':test.xmlns.u
   t/Str
   t/Str
   t/Str
   t/Sym
   t/Str
   clojure.lang.Namespace
   t/Str
   :->
   Ns>xsXs>nsMap])
(t/ann
  element
  (t/IFn
    [':a
     HIJMap
     t/Str
     clojure.data.xml.node.Element
     t/Str
     clojure.data.xml.node.Element
     t/Str
     clojure.data.xml.node.Element
     t/Str
     clojure.data.xml.node.Element
     t/Str
     clojure.data.xml.node.Element
     t/Str
     :->
     clojure.data.xml.node.Element]
    [':foo
     nil
     clojure.data.xml.node.Element
     t/Str
     clojure.data.xml.node.Element
     t/Str
     :->
     clojure.data.xml.node.Element]
    [(t/U ':mixed ':test.xmlns.v/other)
     (t/Map t/Any t/Any)
     :->
     clojure.data.xml.node.Element]
    [(t/U ':body ':e ':comment-stuff)
     (t/Map t/Any t/Any)
     t/Str
     (t/U clojure.data.xml.node.Comment clojure.data.xml.node.Element)
     t/Str
     :->
     clojure.data.xml.node.Element]
    [(t/U ':bar ':a ':body javax.xml.namespace.QName)
     (t/U XmlnsMap (t/Map t/Nothing t/Nothing))
     t/Any
     t/Any
     :->
     clojure.data.xml.node.Element]
    [(t/U
       ':h1
       ':xml.dav/limit
       ':foo
       t/Str
       ':c
       ':g
       ':here
       ':cdata-stuff
       ':d
       ':xml.dav/local-root
       ':comment
       ':ATag
       ':html
       ':xml.dav/nresults
       ':body
       ':f
       ':b
       javax.xml.namespace.QName
       ':cdata
       ':tag
       ':is)
     (t/U
       nil
       (t/Map
         (t/U t/Str javax.xml.namespace.QName ':xmlns/D)
         (t/U t/Str t/Int)))
     t/Any
     :->
     clojure.data.xml.node.Element]
    [(t/U
       ':foo
       ':top-level
       ':test.xmlns.v/other
       javax.xml.namespace.QName)
     :->
     clojure.data.xml.node.Element]))
(t/ann element* AnyFunction)
(t/ann element-nss [clojure.data.xml.node.Element :-> ABMap])
(t/ann
  emit
  (t/IFn
    [clojure.data.xml.node.Element
     (t/U java.io.StringWriter java.io.OutputStreamWriter)
     (t/U ':encoding ':doctype)
     t/Str
     :->
     (t/U java.io.StringWriter java.io.OutputStreamWriter)]
    [alias__25293 java.io.StringWriter :-> java.io.StringWriter]))
(t/ann
  emit-str
  (t/IFn
    [alias__23814 :-> t/Str]
    [clojure.data.xml.node.Element ':doctype t/Str :-> t/Str]))
(t/ann
  event-seq
  [(t/U java.io.ByteArrayInputStream java.io.StringReader)
   (t/U
     nil
     (t/Coll (t/U Boolean ':supporting-external-entities ':coalescing))
     (t/Map t/Nothing t/Nothing))
   :->
   (t/Coll
     (t/U
       clojure.data.xml.event.StartElementEvent
       clojure.data.xml.event.EndElementEvent
       clojure.data.xml.event.CharsEvent))])
(t/ann find-xmlns [clojure.data.xml.node.Element :-> (t/Set t/Str)])
(t/ann
  indent
  (t/IFn
    [clojure.data.xml.node.Element
     java.io.StringWriter
     ':doctype
     t/Str
     :->
     nil]
    [clojure.data.xml.node.Element java.io.StringWriter :-> nil]))
(t/ann
  indent-str
  (t/IFn
    [clojure.data.xml.node.Element ':doctype t/Str :-> t/Str]
    [clojure.data.xml.node.Element :-> t/Str]))
(t/ann ns-uri AnyFunction)
(t/ann
  parse
  (t/IFn
    [java.io.StringReader
     (t/U ':supporting-external-entities ':coalescing)
     Boolean
     :->
     clojure.data.xml.node.Element]
    [(t/U java.io.ByteArrayInputStream java.io.StringReader)
     :->
     clojure.data.xml.node.Element]))
(t/ann parse-qname [t/Str :-> javax.xml.namespace.QName])
(t/ann
  parse-str
  (t/IFn
    [t/Str :-> clojure.data.xml.node.Element]
    [t/Str
     (t/U ':supporting-external-entities ':coalescing)
     Boolean
     :->
     clojure.data.xml.node.Element]))
(t/ann
  qname
  (t/IFn
    [t/Str :-> javax.xml.namespace.QName]
    [t/Str t/Str :-> javax.xml.namespace.QName]))
(t/ann qname-local clojure.lang.Var)
(t/ann qname-uri clojure.lang.Var)
(t/ann
  sexp-as-element
  [(t/Coll t/Any) :-> clojure.data.xml.node.Element])
(t/ann
  sexps-as-fragment
  [(t/Coll '[(t/U ':tag2 ':tag1) t/Str])
   :->
   (t/Coll clojure.data.xml.node.Element)])
(t/ann to-qname AnyFunction)
(t/ann uri-ns AnyFunction)
(t/ann xml-comment AnyFunction)
(t/ann
  clojure.data.xml.event/element-nss
  [clojure.data.xml.node.Element :-> ABMap])
(t/ann
  clojure.data.xml.jvm.emit/string-writer
  [:-> java.io.StringWriter])
(t/ann
  clojure.data.xml.jvm.emit/write-document
  [(t/U java.io.StringWriter java.io.OutputStreamWriter)
   (t/Coll
     (t/U
       clojure.data.xml.event.CommentEvent
       clojure.data.xml.event.StartElementEvent
       clojure.data.xml.event.CDataEvent
       clojure.data.xml.event.EndElementEvent
       clojure.data.xml.event.CharsEvent))
   (t/U nil (t/Map t/Any t/Any))
   :->
   (t/U java.io.StringWriter java.io.OutputStreamWriter)])
(t/ann
  clojure.data.xml.jvm.parse/make-stream-reader
  [CoalescingIncludeNode?SupportingExternalEntitiesMap
   (t/U java.io.ByteArrayInputStream java.io.StringReader)
   :->
   com.sun.org.apache.xerces.internal.impl.XMLStreamReaderImpl])
(t/ann
  clojure.data.xml.jvm.parse/pull-seq
  [com.sun.org.apache.xerces.internal.impl.XMLStreamReaderImpl
   (t/Set (t/U ':element ':characters))
   nil
   :->
   (t/Coll
     (t/U
       clojure.data.xml.event.StartElementEvent
       clojure.data.xml.event.EndElementEvent
       clojure.data.xml.event.CharsEvent))])
(t/ann
  clojure.data.xml.jvm.parse/string-source
  [t/Str :-> java.io.StringReader])
(t/ann
  clojure.data.xml.jvm.pprint/indent-xml
  [t/Str java.io.StringWriter :-> nil])
(t/ann
  clojure.data.xml.name/alias-ns
  [':U
   ':test.xmlns.u
   t/Sym
   t/Sym
   t/Str
   t/Str
   ':D
   ':xml.dav
   ':T
   clojure.lang.Namespace
   :->
   nil])
(t/ann
  clojure.data.xml.name/declare-ns
  [':xml.dav
   t/Str
   ':test.xmlns.u
   t/Str
   t/Str
   t/Str
   t/Sym
   t/Str
   clojure.lang.Namespace
   t/Str
   :->
   Ns>xsXs>nsMap])
(t/ann clojure.data.xml.name/ns-uri AnyFunction)
(t/ann
  clojure.data.xml.name/parse-qname
  [t/Str :-> javax.xml.namespace.QName])
(t/ann
  clojure.data.xml.name/qname
  (t/IFn
    [t/Str :-> javax.xml.namespace.QName]
    [t/Str t/Str :-> javax.xml.namespace.QName]))
(t/ann clojure.data.xml.name/qname-local clojure.lang.Var)
(t/ann clojure.data.xml.name/qname-uri clojure.lang.Var)
(t/ann clojure.data.xml.name/to-qname AnyFunction)
(t/ann clojure.data.xml.name/uri-ns AnyFunction)
(t/ann clojure.data.xml.node/cdata AnyFunction)
(t/ann
  clojure.data.xml.node/element
  (t/IFn
    [(t/U
       ':h1
       ':xml.dav/limit
       ':foo
       t/Str
       ':c
       ':g
       ':here
       ':cdata-stuff
       ':d
       ':xml.dav/local-root
       ':comment
       ':ATag
       ':html
       ':xml.dav/nresults
       ':body
       ':f
       ':b
       javax.xml.namespace.QName
       ':cdata
       ':tag
       ':is)
     (t/U
       nil
       (t/Map
         (t/U t/Str javax.xml.namespace.QName ':xmlns/D)
         (t/U t/Str t/Int)))
     t/Any
     :->
     clojure.data.xml.node.Element]
    [(t/U ':bar ':a ':body javax.xml.namespace.QName)
     (t/U XmlnsMap (t/Map t/Nothing t/Nothing))
     t/Any
     t/Any
     :->
     clojure.data.xml.node.Element]
    [':a
     HIJMap
     t/Str
     clojure.data.xml.node.Element
     t/Str
     clojure.data.xml.node.Element
     t/Str
     clojure.data.xml.node.Element
     t/Str
     clojure.data.xml.node.Element
     t/Str
     clojure.data.xml.node.Element
     t/Str
     :->
     clojure.data.xml.node.Element]
    [(t/U ':body ':e ':comment-stuff)
     (t/Map t/Any t/Any)
     t/Str
     (t/U clojure.data.xml.node.Comment clojure.data.xml.node.Element)
     t/Str
     :->
     clojure.data.xml.node.Element]
    [(t/U
       ':foo
       ':top-level
       ':test.xmlns.v/other
       javax.xml.namespace.QName)
     :->
     clojure.data.xml.node.Element]
    [(t/U ':mixed ':test.xmlns.v/other)
     (t/Map t/Any t/Any)
     :->
     clojure.data.xml.node.Element]
    [':foo
     nil
     clojure.data.xml.node.Element
     t/Str
     clojure.data.xml.node.Element
     t/Str
     :->
     clojure.data.xml.node.Element]))
(t/ann clojure.data.xml.node/element* AnyFunction)
(t/ann clojure.data.xml.node/xml-comment AnyFunction)
(t/ann
  clojure.data.xml.process/aggregate-xmlns
  [clojure.data.xml.node.Element :-> clojure.data.xml.node.Element])
(t/ann
  clojure.data.xml.process/find-xmlns
  [clojure.data.xml.node.Element :-> (t/Set t/Str)])
(t/ann
  clojure.data.xml.prxml/sexp-as-element
  [(t/Coll t/Any) :-> clojure.data.xml.node.Element])
(t/ann
  clojure.data.xml.prxml/sexps-as-fragment
  [(t/Coll '[(t/U ':tag2 ':tag1) t/Str])
   :->
   (t/Coll clojure.data.xml.node.Element)])
(t/ann
  clojure.data.xml.tree/event-tree
  [(t/Coll
     (t/U
       clojure.data.xml.event.StartElementEvent
       clojure.data.xml.event.EndElementEvent
       clojure.data.xml.event.CharsEvent))
   :->
   clojure.data.xml.node.Element])
(t/ann
  clojure.data.xml.tree/flatten-elements
  ['[alias__24617]
   :->
   (t/Coll
     (t/U
       clojure.data.xml.event.CommentEvent
       clojure.data.xml.event.StartElementEvent
       clojure.data.xml.event.CDataEvent
       clojure.data.xml.event.EndElementEvent
       clojure.data.xml.event.CharsEvent))])
;; End: Generated by clojure.core.typed - DO NOT EDIT
(export-api node/element* node/element node/cdata node/xml-comment
            prxml/sexp-as-element prxml/sexps-as-fragment event/element-nss
            name/ns-uri name/uri-ns name/declare-ns name/alias-ns
            name/parse-qname name/qname-uri name/qname-local name/qname name/to-qname
            process/find-xmlns process/aggregate-xmlns)

(defn canonical-name
  "Put (q)name into canonical form as per ns-env"
  [n]
  (name/canonical-name (qname-uri n) (qname-local n) ""))

(defn event-seq
  "Parses the XML InputSource source using a pull-parser. Returns
   a lazy sequence of Event records.  Accepts key pairs
   with XMLInputFactory options, see http://docs.oracle.com/javase/6/docs/api/javax/xml/stream/XMLInputFactory.html
   and xml-input-factory-props for more information.
   Defaults coalescing true and supporting-external-entities false.
   :include-node? can be a set of #{:start-element :end-element :characters :comment}"
  [source {:as props}]
  (let [props* (merge {:include-node? #{:element :characters}
                       :coalescing true
                       :supporting-external-entities false}
                      props)]
    (pull-seq (make-stream-reader props* source)
              (get props* :include-node?)
              nil)))

(defn parse
  "Parses the source, which can be an
   InputStream or Reader, and returns a lazy tree of Element records. Accepts key pairs
   with XMLInputFactory options, see http://docs.oracle.com/javase/6/docs/api/javax/xml/stream/XMLInputFactory.html
   and xml-input-factory-props for more information. Defaults coalescing true."
  [source & opts]
  (event-tree (event-seq source opts)))

(defn parse-str
  "Parses the passed in string to Clojure data structures.  Accepts key pairs
   with XMLInputFactory options, see http://docs.oracle.com/javase/6/docs/api/javax/xml/stream/XMLInputFactory.html
   and xml-input-factory-props for more information. Defaults coalescing true."
  [s & opts]
  (apply parse (string-source s) opts))

(defn emit
  "Prints the given Element tree as XML text to stream.
   Options:
    :encoding <str>          Character encoding to use
    :doctype  <str>          Document type (DOCTYPE) declaration to use"
  [e writer & {:as opts}]
  (write-document writer (flatten-elements [e]) opts))

(defn emit-str
  "Emits the Element to String and returns it.
   Options:
    :encoding <str>          Character encoding to use
    :doctype  <str>          Document type (DOCTYPE) declaration to use"
  ([e & opts]
   (let [sw (string-writer)]
     (apply emit e sw opts)
     (str sw))))

(defn indent
  "Emits the XML and indents the result.  WARNING: this is slow
   it will emit the XML and read it in again to indent it.  Intended for
   debugging/testing only."
  [e writer & opts]
  (indent-xml (apply emit-str e opts) writer))

(defn indent-str
  "Emits the XML and indents the result.  Writes the results to a String and returns it"
  [e & opts]
  (let [sw (string-writer)]
    (apply indent e sw opts)
    (str sw)))

;; TODO implement ~normalize to simulate an emit-parse roundtrip
;;      in terms of xmlns environment and keywords vs qnames