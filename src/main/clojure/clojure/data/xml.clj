;   Copyright (c) Rich Hickey. All rights reserved.
;   The use and distribution terms for this software are covered by the
;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)
;   which can be found in the file epl-v10.html at the root of this distribution.
;   By using this software in any fashion, you are agreeing to be bound by
;   the terms of this license.
;   You must not remove this notice, or any other, from this software.

(ns ^{:doc "Functions to parse XML into lazy sequences and lazy trees and
  emit these as text."
      :author "Chris Houser"
      :lang :core.typed
      :core.typed {:features #{:runtime-infer}}}

  clojure.data.xml
  
  (:require
   (clojure.data.xml
    [process :as process]
    [impl :refer [export-api]]
    [node :as node]
    [prxml :as prxml]
    [name :as name]
    [event :as event])
   (clojure.data.xml.jvm
    [pprint :refer
     [indent-xml]]
    [parse :refer
     [pull-seq string-source make-stream-reader]]
    [emit :refer
     [write-document string-writer]])
   
   [clojure.core.typed :as t]
   [clojure.spec :as s]
   [clojure.data.xml.tree :refer
    [event-tree flatten-elements]]))

;; Start: Generated by clojure.core.typed - DO NOT EDIT
(s/fdef
  alias-ns
  :args
  (s/cat
    :alias-ns-0
    keyword?
    :alias-ns-1
    keyword?
    :alias-ns-2
    symbol?
    :alias-ns-3
    symbol?
    :alias-ns-4
    string?
    :alias-ns-5
    string?
    :alias-ns-6
    keyword?
    :alias-ns-7
    keyword?
    :alias-ns-8
    keyword?
    :alias-ns-9
    (partial instance? clojure.lang.Namespace))
  :ret
  nil?)
(s/def
  :keys44460/xs->ns
  (s/and (s/map-of string? (s/or :string? string? :symbol? symbol?))))
(s/def
  :keys44460/ns->xs
  (s/and (s/map-of (s/or :string? string? :symbol? symbol?) string?)))
(s/def
  ::Ns>xsXs>nsMap
  (s/keys :req-un [:keys44460/xs->ns :keys44460/ns->xs]))
(s/fdef
  declare-ns
  :args
  (s/cat
    :declare-ns-0
    keyword?
    :declare-ns-1
    string?
    :declare-ns-2
    keyword?
    :declare-ns-3
    string?
    :declare-ns-4
    string?
    :declare-ns-5
    string?
    :declare-ns-6
    symbol?
    :declare-ns-7
    string?
    :declare-ns-8
    (partial instance? clojure.lang.Namespace)
    :declare-ns-9
    string?)
  :ret
  ::Ns>xsXs>nsMap)
(s/fdef
  aggregate-xmlns
  :args
  (s/cat :xml (partial instance? clojure.data.xml.node.Element))
  :ret
  (partial instance? clojure.data.xml.node.Element))
(s/fdef
  sexp-as-element
  :args
  (s/cat :sexp (s/coll-of any?))
  :ret
  (partial instance? clojure.data.xml.node.Element))
(s/fdef
  indent
  :args
  (s/alt
    :4-args
    (s/cat
      :e
      (partial instance? clojure.data.xml.node.Element)
      :writer
      (partial instance? java.io.StringWriter)
      :&
      keyword?
      :opts
      string?)
    :2-args
    (s/cat
      :indent-0
      (partial instance? clojure.data.xml.node.Element)
      :indent-1
      (partial instance? java.io.StringWriter)))
  :ret
  nil?)
(s/def
  ::ABMap
  (s/keys
    :req
    [:FIXME-SHOULD-BE-NAMESPACED-xmlns/b
     :FIXME-SHOULD-BE-NAMESPACED-xmlns/a]))
(s/fdef
  element-nss
  :args
  (s/cat
    :element-nss-0
    (partial instance? clojure.data.xml.node.Element))
  :ret
  ::ABMap)
(s/fdef
  indent-str
  :args
  (s/alt
    :3-args
    (s/cat
      :e
      (partial instance? clojure.data.xml.node.Element)
      :&
      keyword?
      :opts
      string?)
    :1-args
    (s/cat
      :indent-str-0
      (partial instance? clojure.data.xml.node.Element)))
  :ret
  string?)
(s/fdef
  parse
  :args
  (s/alt
    :3-args
    (s/cat
      :source
      (partial instance? java.io.StringReader)
      :&
      keyword?
      :opts
      boolean?)
    :1-args
    (s/cat
      :parse-0
      (s/or
        :G__44462
        (partial instance? java.io.ByteArrayInputStream)
        :G__44463
        (partial instance? java.io.StringReader))))
  :ret
  (partial instance? clojure.data.xml.node.Element))
(s/def :keys44473/xmlns string?)
(s/def ::XmlnsMap (s/keys :req-un [:keys44473/xmlns]))
(s/def :keys44474/j string?)
(s/def :keys44474/h string?)
(s/def :keys44474/i string?)
(s/def
  ::HIJMap
  (s/keys :req-un [:keys44474/j :keys44474/h :keys44474/i]))
(s/fdef
  element
  :args
  (s/alt
    :13-args
    (s/cat
      :element-0
      keyword?
      :element-1
      ::HIJMap
      :element-2
      string?
      :element-3
      (partial instance? clojure.data.xml.node.Element)
      :element-4
      string?
      :element-5
      (partial instance? clojure.data.xml.node.Element)
      :element-6
      string?
      :element-7
      (partial instance? clojure.data.xml.node.Element)
      :element-8
      string?
      :element-9
      (partial instance? clojure.data.xml.node.Element)
      :element-10
      string?
      :element-11
      (partial instance? clojure.data.xml.node.Element)
      :element-12
      string?)
    :6-args
    (s/cat
      :element-0
      keyword?
      :element-1
      nil?
      :element-2
      (partial instance? clojure.data.xml.node.Element)
      :element-3
      string?
      :element-4
      (partial instance? clojure.data.xml.node.Element)
      :element-5
      string?)
    :4-args
    (s/cat
      :tag
      (s/or
        :G__44464
        (partial instance? javax.xml.namespace.QName)
        :keyword?
        keyword?)
      :attrs
      (s/or :G__44465 ::XmlnsMap :G__44466 (s/map-of (s/or) (s/or)))
      :&
      any?
      :content
      any?)
    :2-args
    (s/cat :tag keyword? :attrs (s/map-of any? any?))
    :5-args
    (s/cat
      :element-0
      keyword?
      :element-1
      (s/map-of any? any?)
      :element-2
      string?
      :element-3
      (s/or
        :G__44467
        (partial instance? clojure.data.xml.node.Comment)
        :G__44468
        (partial instance? clojure.data.xml.node.Element))
      :element-4
      string?)
    :3-args
    (s/cat
      :element-0
      (s/or
        :G__44469
        (partial instance? javax.xml.namespace.QName)
        :keyword?
        keyword?
        :string?
        string?)
      :element-1
      (s/or
        :G__44471
        (s/map-of
          (s/or
            :G__44470
            (partial instance? javax.xml.namespace.QName)
            :string?
            string?
            :keyword?
            keyword?)
          (s/or :string? string? :int? int?))
        :nil?
        nil?)
      :element-2
      any?)
    :1-args
    (s/cat
      :tag
      (s/or
        :G__44472
        (partial instance? javax.xml.namespace.QName)
        :keyword?
        keyword?)))
  :ret
  (partial instance? clojure.data.xml.node.Element))
(s/fdef
  qname
  :args
  (s/alt
    :1-args
    (s/cat :name string?)
    :2-args
    (s/cat :uri string? :name string?))
  :ret
  (partial instance? javax.xml.namespace.QName))
(s/def
  ::alias__25934
  (s/or
    :G__44490
    (partial instance? clojure.data.xml.node.Element)
    :G__44491
    (s/coll-of
      (s/or
        :G__44487
        (partial instance? clojure.data.xml.event.StartElementEvent)
        :G__44488
        (partial instance? clojure.data.xml.event.CharsEvent)
        :G__44489
        (partial instance? clojure.data.xml.event.EndElementEvent)))
    :G__44492
    ::ContentTagAttrsMap))
(s/def
  ::alias__26660
  (s/or
    :G__44496
    (partial instance? clojure.data.xml.node.Element)
    :G__44497
    (s/coll-of
      (s/or
        :G__44493
        (partial instance? clojure.data.xml.event.StartElementEvent)
        :G__44494
        (partial instance? clojure.data.xml.event.CharsEvent)
        :G__44495
        (partial instance? clojure.data.xml.event.EndElementEvent)))
    :G__44498
    ::ContentTagAttrsMap))
(s/def
  :keys44481/content
  (s/or
    :string?
    string?
    :G__44486
    (s/tuple
      (s/or
        :G__44483
        ::alias__26660
        :string?
        string?
        :G__44484
        ::alias__25112
        :G__44485
        ::alias__25934))))
(s/def :keys44481/tag (s/or :string? string? :keyword? keyword?))
(s/def
  :keys44482/attrs
  (s/and
    (s/map-of
      (s/or :string? string? :keyword? keyword?)
      (s/or :string? string? :int? int?))))
(s/def
  ::ContentTagAttrsMap
  (s/keys
    :req-un
    [:keys44481/content :keys44481/tag]
    :opt-un
    [:keys44482/attrs]))
(s/def
  ::alias__25112
  (s/or
    :G__44478
    (partial instance? clojure.data.xml.node.Element)
    :G__44479
    (s/coll-of
      (s/or
        :G__44475
        (partial instance? clojure.data.xml.event.StartElementEvent)
        :G__44476
        (partial instance? clojure.data.xml.event.CharsEvent)
        :G__44477
        (partial instance? clojure.data.xml.event.EndElementEvent)))
    :G__44480
    ::ContentTagAttrsMap))
(s/fdef
  emit-str
  :args
  (s/alt
    :1-args
    (s/cat :emit-str-0 ::alias__25112)
    :3-args
    (s/cat
      :e
      (partial instance? clojure.data.xml.node.Element)
      :&
      keyword?
      :opts
      string?))
  :ret
  string?)
(s/fdef
  parse-str
  :args
  (s/alt
    :1-args
    (s/cat :parse-str-0 string?)
    :3-args
    (s/cat :s string? :& keyword? :opts boolean?))
  :ret
  (partial instance? clojure.data.xml.node.Element))
(s/fdef
  parse-qname
  :args
  (s/cat :parse-qname-0 string?)
  :ret
  (partial instance? javax.xml.namespace.QName))
(s/fdef
  sexps-as-fragment
  :args
  (s/cat :sexp (s/coll-of (s/tuple keyword? string?)))
  :ret
  (s/coll-of (partial instance? clojure.data.xml.node.Element)))
(s/fdef
  event-seq
  :args
  (s/cat
    :event-seq-0
    (s/or
      :G__44499
      (partial instance? java.io.ByteArrayInputStream)
      :G__44500
      (partial instance? java.io.StringReader))
    :event-seq-1
    (s/or
      :nil?
      nil?
      :G__44501
      (s/coll-of (s/or :keyword? keyword? :boolean? boolean?))
      :G__44502
      (s/map-of (s/or) (s/or))))
  :ret
  (s/coll-of
    (s/or
      :G__44512
      (partial instance? clojure.data.xml.event.StartElementEvent)
      :G__44513
      (partial instance? clojure.data.xml.event.CharsEvent)
      :G__44514
      (partial instance? clojure.data.xml.event.EndElementEvent))))
(s/fdef
  emit
  :args
  (s/alt
    :4-args
    (s/cat
      :emit-0
      (partial instance? clojure.data.xml.node.Element)
      :emit-1
      (s/or
        :G__44515
        (partial instance? java.io.OutputStreamWriter)
        :G__44516
        (partial instance? java.io.StringWriter))
      :emit-2
      keyword?
      :emit-3
      string?)
    :2-args
    (s/cat
      :emit-0
      ::alias__26660
      :emit-1
      (partial instance? java.io.StringWriter)))
  :ret
  (s/or
    :G__44517
    (partial instance? java.io.OutputStreamWriter)
    :G__44518
    (partial instance? java.io.StringWriter)))
(s/fdef
  find-xmlns
  :args
  (s/cat :xml (partial instance? clojure.data.xml.node.Element))
  :ret
  set?)
;; End: Generated by clojure.core.typed - DO NOT EDIT
(export-api node/element* node/element node/cdata node/xml-comment
            prxml/sexp-as-element prxml/sexps-as-fragment event/element-nss
            name/ns-uri name/uri-ns name/declare-ns name/alias-ns
            name/parse-qname name/qname-uri name/qname-local name/qname name/to-qname
            process/find-xmlns process/aggregate-xmlns)

(defn canonical-name
  "Put (q)name into canonical form as per ns-env"
  [n]
  (name/canonical-name (qname-uri n) (qname-local n) ""))

(defn event-seq
  "Parses the XML InputSource source using a pull-parser. Returns
   a lazy sequence of Event records.  Accepts key pairs
   with XMLInputFactory options, see http://docs.oracle.com/javase/6/docs/api/javax/xml/stream/XMLInputFactory.html
   and xml-input-factory-props for more information.
   Defaults coalescing true and supporting-external-entities false.
   :include-node? can be a set of #{:start-element :end-element :characters :comment}"
  [source {:as props}]
  (let [props* (merge {:include-node? #{:element :characters}
                       :coalescing true
                       :supporting-external-entities false}
                      props)]
    (pull-seq (make-stream-reader props* source)
              (get props* :include-node?)
              nil)))

(defn parse
  "Parses the source, which can be an
   InputStream or Reader, and returns a lazy tree of Element records. Accepts key pairs
   with XMLInputFactory options, see http://docs.oracle.com/javase/6/docs/api/javax/xml/stream/XMLInputFactory.html
   and xml-input-factory-props for more information. Defaults coalescing true."
  [source & opts]
  (event-tree (event-seq source opts)))

(defn parse-str
  "Parses the passed in string to Clojure data structures.  Accepts key pairs
   with XMLInputFactory options, see http://docs.oracle.com/javase/6/docs/api/javax/xml/stream/XMLInputFactory.html
   and xml-input-factory-props for more information. Defaults coalescing true."
  [s & opts]
  (apply parse (string-source s) opts))

(defn emit
  "Prints the given Element tree as XML text to stream.
   Options:
    :encoding <str>          Character encoding to use
    :doctype  <str>          Document type (DOCTYPE) declaration to use"
  [e writer & {:as opts}]
  (write-document writer (flatten-elements [e]) opts))

(defn emit-str
  "Emits the Element to String and returns it.
   Options:
    :encoding <str>          Character encoding to use
    :doctype  <str>          Document type (DOCTYPE) declaration to use"
  ([e & opts]
   (let [sw (string-writer)]
     (apply emit e sw opts)
     (str sw))))

(defn indent
  "Emits the XML and indents the result.  WARNING: this is slow
   it will emit the XML and read it in again to indent it.  Intended for
   debugging/testing only."
  [e writer & opts]
  (indent-xml (apply emit-str e opts) writer))

(defn indent-str
  "Emits the XML and indents the result.  Writes the results to a String and returns it"
  [e & opts]
  (let [sw (string-writer)]
    (apply indent e sw opts)
    (str sw)))

;; TODO implement ~normalize to simulate an emit-parse roundtrip
;;      in terms of xmlns environment and keywords vs qnames